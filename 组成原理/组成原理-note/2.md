## 计算机组成原理
---
### 1. BCD码（用二进制编码的十进制）
```java
1.8421码：（有权，权值就是8421）
① 8421码的映射关系：0-9（0000-1001）
（修正：超出9之后的数没法表示，需要+6，高位进1，然后前面补000，最终将十位和个位分别表示）
例如：5+8=13  0101+1000=1101（1101没法表示，要+6，最终为 0001 0011）

2.余3码：（无权）
① 再8421码的基础上+3

3.2421码：（有权，权值就是2421）
① 0-4:0000 0001 0010 0011 0100
② 5-9：1011 1100 1101 1110 1111（规定5之后最高位为1）

```

### 2. 校验原理
```java
1. 校验原理（位错误：0变1，1变0） 
① 将两个码字逐位进行对比，具有不同的位的个数称为两个码字间的距离
② 一种编码方案可能有若干个合法码字，各合法码字间的最小距离称为“码距”
（当码距d=1时，无检错能力；当d=2时，有检错能力；当d>=3时，若设计合理，可能具有检错、纠错能力）
```

### 2.1 校验 - 奇偶校验码
```java
1. 奇校验就是一共奇数个1，偶校验就是一共偶数个1
2. 通过接收奇校验或者偶校验判断1个bit位错误后，奇变偶或者偶变奇，则证明发生错误，
（但是当2个bit位错误后，也会满足奇偶校验，无法判断发生错误）

3.（下面举例偶校验）
校验码：最高位为校验码，对信息位全部异或可求出校验码
信息位：除最高位以外都是信息位

校验：对校验码和信息位全部进行异或
（当偶校验结果为0则完整，为1则错误，但是2个bit位错误也会导致结果为0，所以只能检测1bit位）
```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:860px;"><img src="组成原理/img/奇偶校验.jpg" alt=""></div>
</div>

### 2.2 校验 - 海明校验码（偶校验的基础上）
```java
1. 确定海明码的位数：2^k >= n+k+1（k为校验位、n为信息位）
2. 设信息位D4D3D2D1，校验位P3P2P1，对应的海明码为H7H6H5H4H3H2H1
3. 确定校验位的分布（校验位分布再二进制的权值上8421）
4. 列出信息位用二进制表示，他们几个信息位之间的1权值、2权值、4权值分别对应给校验位P1P2P3，为1的则异或，0不管，结果为该检验位的值
5. 纠错：为第4步加上检验位的异或，为0则完整，1则错误
6. 检错：将各个纠错后的二进制数连起来就是出错数
-------------------------------
补充：
海明码具有1位纠错、2位检错（当2位错误时，无法判断是1位还是2位错）
1. 需要再海明码前面上加一个“全校验位”H8，对整体进行偶校验（令海明码为偶数个1）
纠错为0，且全体校验成功 -> 无错误
纠错不为0，且全体偶校验失败 -> 有1位错，纠正即可
纠错不为0，且全体偶校验成功 -> 有2位错，需重传

```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:860px;"><img src="组成原理/img/海明码校验.jpg" alt=""></div>
</div>


### 2.3 校验 - CRC循环冗余校验码
```java
1. 生成多项式：出现的幂为1，没出现的为0（x³+x²+1 = 1101）
2. 信息位：K为信息位的长度（101001）
3. 信息位变校验位：信息位左移R位，R为最高次幂的幂数，后面补R个0（101001000）
4. 相除：模2除，校验位除多项式二进制，就是进行异或（101001000/1101）
（相除过程中，除数每次的最高位若为1，则商为1正常异或被除数。若为0，则商为0继续从除数中拿下一个数补上）
5. 最终的余数就是校验位，校验位比多项式少一位，且把校验位补在信息位后（余数001，则CRC：101001001）
6. 检错纠错：接收方将CRC码/多项式，为000则没出错
-------------------------------
补充：
CRC循环冗余校验码是具有纠错功能的，只是信息位不能太多
```

### 3. 定点数的表示（无符号、有符号的原反补移）
```java
1. 无符号数的表示：（一般讨论无符号数的正数，不谈小数）
① 范围：8位 0-255（0 - 2^n-1）

2. 有符号数的定点表示：（若机器字长为n+1位，则尾数占n位）
① 定点整数：最高位为符号位 0正 1负，小数点位置在最后（[x]原=1,0010011，如没说明机器字长，可写[x]原=1,10011）
② 定点小数：最高位为符号位 0正 1负，小数点位置在符号位后（[x]原=1.1100000）
（注意：定点整数逗号，定点小数的点，是区分符号位和尾数的）
------------------------------------------
（以下原码、反码、补码，说的是整数和小数）
原码：（若机器字长为n+1位，则尾数占n位，其实就是少1位作为符号位）（真值0有+0和-0两种）
① 原码整数范围：-(2^n-1) ≤ x ≤ 2^n-1  
② 原码小数范围：-(1-2^-n) ≤ x ≤ 1-2^-n


反码：（没用，作为中转）（真值0有+0和-0两种）
① 符号位正，则数值不变
② 符号位负，则数值取反

补码：（要考虑可能会进位）（真值0只有一种）
① 符号位正，则数值不变
② 符号位负，则数值变反码，再反码上+1
③ 补码转原码也是一样，变反再+1

移码：（移码只能用于表示整数）（真值0只有一种）
① 符号位正，则符号位取反
② 符号位负，则在补码基础上符号位取反
③ 移码转原码也是一样，正符号位取反，负变反再+1
------------------------------------------
（因为补码和移码真值0只有一种形式，所以比原码和反码多一个负数表示形式 -128）
（技巧：由[x]快速求[-x]的方法，符号位、数值位全部取反，末位+1）
```

### 4 定点数的运算
```java
1. 定点数的运算：
① 移位运算
② 加减运算（减转换为加）
③ 乘法运算
④ 除法运算
```

### 4.1 定点数的运算 - 移位运算
```java
1. 算术移位：（整数或者小数写成8位二进制进行移位）
① 原码：（以下基于整数讨论，小数也是同样道理）
右移：高位补0，低位舍弃。若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度
左移：高位舍弃，低位补0。若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差

② 反码：
正数：跟原码移位相同
负数：高位或者低位补的是1，而不是0

③ 补码：
正数：跟原码移位相同
负数：因为补码+1，会导致补码的左边部分会和反码一致，而右边部分会和原码一致，所以右移(同反码)补1，左移(同原码)补0
（道理就是补码会在右边+1，相当于取反。直到取出1来，相当于进位1，所以会分成左右两部分）
---------------------------------
补充：
算术移位的举例：-20*7的运算
① 把7拆成二进制权值：2^2 + 2^1 + 2^0（就是 -20*(2^2 + 2^1 + 2^0)）
② 计算机会左移2位+左移1位+不移位

2. 逻辑移位：（可以看做是对无符号数的算术移位）
右移：高位补0，低位舍弃
左移：低位补0，高位舍弃

3. 循环移位：（右移左移丢弃的位数补到另一边）
带进位位的循环：多一个位存进位的数，可以存最高位的进位或者补到另一边
```


### 4.2 定点数的运算 - 加减运算（溢出判断）
```java
无符号的加减：（无符号计算符号不用参与，因为没有符号，所以8bit数值位正常进行加法计算）
① 加：加后符号位产生的进位可丢弃
② 减：减数变(补码)，换成加法
-----------------------------------------------------------
有符号的加减：
1.补码：（有符号的补码符号位正常参与计算、求该真值需要转回原码）
① 加：加后符号位产生的进位可丢弃
② 减：减数变(负补)，换成加法 （其实原理跟无符号的减法一样，只是无符号没有符号位所以直接变补码就行，而补码变补码还要变符号位，所以为负补）

原补转换方式：（3种，一般看后2种）
① 传统的原补转换法：原-反-补 转换（符号位不动）
② 补码的移位运算法：负补，找到最右边的1，1左边取反，1右边包括1在内不变（符号位不动）
③ 正补转负补 或者 负补转正补：符号位数值位全部取反+1（符号位要动）


2.原码：（补码是机器易懂，原码则要考虑符号位了）
① 加：
正+正：绝对值做加法，符号位为正
负+负：绝对值做加法，符号位为负
正+负：绝对值做减法且大-小，符号位跟大的一样
负+正：绝对值做减法且大-小，符号位跟大的一样
② 减：“减数”符号取反，转变为原码加法（1-(-1) -> 1+1）
  
-----------------------------------------------------------
溢出判断：
1.什么是溢出：是指计算出来的二进制数跟实际真值不同，符号位的进位被丢弃（-128 - 127）

2.为什么会产生溢出：（补码和原码一样的道理，正正相加、负负相加会溢出）
正+正：溢出
负+负：溢出

3.判断溢出：（3种）
举个溢出的例子和溢出判断方法：
[A+C]补 = 0,0001111+0,1111100 = 1,0001011  真值-117 （溢出）
[-B-C]补 = 1,1101000+1,0000100 = 0,1101100  真值+108 （溢出）

① 方法一：（类似数电）
V=AsBsSs' + As'Bs'Ss （A表示加数1的符号位，B表示加数2的符号位，S表示结果的符号位，在+号前是对负负溢出判断，在后是对正正溢出判断）'
若V=0，则无溢出；
若V=1，则有溢出。

② 方法二：采用一位符号位，跟数据位进位情况（符号位进位是存符号位的进位，最高数值位是存符号位）
上溢：符号位进位Cs = 0，最高数值位进位C1 = 1 （这里C1=1可看成符号位是1，符号位进位不用进位）
下溢：符号位进位Cs = 1，最高数值位进位C1 = 0 （这里C1=0可看成符号位是1，+1符号位进位用进位，符号位重新为0）
因此Cs和C1不同时有溢出，可做Cs异或C1判断
若V=0，表示无溢出；（相同无溢出）
若V=1，表示有溢出。（不同有溢出）

③ 方法三：采用双符号位
[A+C]补 = 00,0001111+00,1111100 = 01,0001011  真值-117 （溢出）
[B-C]补 = 11,1101000+11,0000100 = 10,1101100  真值+108 （溢出）
正数符号为00，负数符号为11（而结果的双符号左边的为正确结果，右边为实际的错误结果）
双符号位分别为S1、S2，因此S1和S2不同时有溢出，可做S1异或S2判断
若V=0，表示无溢出；（相同无溢出）
若V=1，表示有溢出。（不同有溢出）

-----------------------------------------------------------
4.符号扩展：
因为溢出就是数据不够存，短数据要变长数据，多出的那些位就要考虑符号扩展
--------------------------
举个例子：8位->16位

（定点正数：符号与数值中间添）
① 正整数：0,1011010 -> 0,00000000 1011010（原、反、补都一样）

② 负正数：
原码：1,1011010 -> 1,00000000 1011010（正常补0）
反码：1,0100101 -> 1,11111111 0100101（反码补1）
补码：1,0100110 -> 1,11111111 0100110（补码找到数值最右的1，1左边反码，1右边包括1原码）

（定点小数：数值位后添）
③ 正小数：0.1011010 -> 0.1011010 00000000(原、反、补码的表示都一样)

④ 负小数:
原码：1.1011010 -> 1.1011010 00000000（正常补0）
反码：1.0100101 -> 1.0100101 11111111（反码补1）
补码：1.0100110 -> 1.0100110 00000000（补码找到数值最右的1，1左边反码，1右边包括1原码）
```

### 4.3 定点数的运算 - 乘运算（一位乘法：先加法再移位，重复n次）
```java
讲在前面：12*34
① 手算乘法：
计算过程为什么要错位，因为3和4会单独跟12乘的，4会先乘，但是4处于的位权会比3的位权低一位，
为了让位权保持正确，我们每次会把高一位的位权算出来的那个结果向左移一位，来确保3的位权比4大，
② 机器乘法：
是先对低一位进行操作移位的，所以机器是把低一位的位权算出来的那个结果向右移一位（相当于高一位的位权算出来的那个结果向左移一位）

相反，如果是除法，则每次会把结果都向右移一位，来确保3的位权比4大


1.原码的乘法：（符号位异或，值取绝对值n次相加，n是数值位个数）
① 当前MQ的乘积低位是1，则ACC乘积高位加上X被乘数的值
② 当前MQ的乘积低位是0，则ACC加上0

机器计算步骤：（如果机器字长位5位，含1位符号位，则数值位是4位，共计算4次）
① 首先ACC乘积高位先置0，并且乘数和被乘数都取绝对值（符号位为0）
② 先判断MQ的乘积低位（就是乘数最右边的数）是1还是0
③ 1的话ACC就加上X被乘数，0的话加0，接着ACC和MQ一起向右移位（ACC的高位到MQ，MQ的低位丢弃）
④ 右移补0（原码补0）
⑤ 下次同样进行判断MQ低位是1还是0进行相加
⑥ 最后ACC乘积高位和MQ乘积低位就是结果
⑦ 符号进行异或得出
-------------------
运算器内部运行：（ACC累加器、MQ乘商寄存器、X通用寄存器）
ACC(乘积高位) →← MQ(乘数、乘积低位)
    ↑↓
   ALU
    ↑
 X(被乘数)

---------------------------------------------------------
2.补码的乘法：（跟原码一样，不同是还多了辅助位、最后要多来一次加法让符号位参与运算、补码算术移位、有3种加法判断）
① 写出x、y的补码，并且x要有正补码和负补码，x正补、x负补还有0是3种加法的判断
① 辅助位：ACC的辅助位在前面为0，X的辅助位在前面跟符号位相同，MQ辅助位在后一开始为0，后面通过右移会改变，从而判断3种加法判断
② MQ辅助位-MQ最低位为1，则ACC加上[x]补
  MQ辅助位-MQ最低位为0，则ACC加上0
  MQ辅助位-MQ最低位为-1，则ACC加上[-x]补

机器计算步骤：（如果机器字长位5位，含1位符号位，则数值位是4位，补码多加依次，共计算5次）
① 首先ACC乘积高位先置0
② 进行MQ辅助位-MQ最低位，结果有3种情况分别对应加上[x]补、0、[-x]补
③ 右移，ACC符号位不动，ACC数值位和MQ统一右移（正数补0，负数补1，符号取决于ACC符号位）
④ 补码最后会多加一次，但最后一次不用右移，并且最后一次是符号位参与运算，能够天然得到结果的正负
⑤ 最后将ACC的结果和MQ的值拼接起来（MQ的值通过右移得来的，其中MQ的符号位和辅助位已经通过右移全都丢掉了，所以注意是没加MQ的符号位和辅助位的）
⑥ 最后结果还要转换为原码，例如：[xy]补=11.01110001 即xy =-0.10001111
```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:860px;"><img src="组成原理/img/原码乘法.jpg" alt=""></div>
<div style="width:860px;"><img src="组成原理/img/补码乘法.jpg" alt=""></div>
</div>

### 4.4 定点数的运算 - 除运算（重复n次）
```java
1.原码的除法：（恢复余数法）
① 需要：x和y的绝对值、y的绝对值补码、y的绝对值负补
② 计算时将x、y小数点去掉
③ 上商0或者1，得到余数，余数末尾补0
④ 符号位不参与运算（这也是为什么要加绝对值的原因），最后单独异或

机器计算步骤：（如果机器字长位5位，含1位符号位，则数值位是4位）
① MQ低位先默认为1，执行ACC余数-X除数（机器没减法电路，所以转变为：ACC余数+y的绝对值负补）
② 把ACC和X的值送到ALU计算，结果放回ACC，如果出现符号位为1，证明ACC余数小，原来的MQ商低位为1是错的，把1改为0
③ 恢复余数，重新改为：ACC余数+y的绝对值补码（注意这次+的是y的绝对值补码，不是负补），此时ACC余数的结果符号位应为0
④ ACC和MQ左移，将ACC余数的高位0丢弃，MQ的低位补0
⑤ 下次计算继续MQ低位先默认为1，如果ACC余数符号位为0，则结果正确，左移（最后一次如果MQ为1，但ACC余数符号位为负，也要恢复才能结束）
⑥ 最后结果为：余数 * 2-^n

1.原码的除法：（加减交替法、又名：不恢复余数法）
① 若余数为负，则可直接商0，让余数左移1位再+y的绝对值补码
② 若余数为正，则可直接商1，让余数左移1位再+y的绝对值负补
③ 最后余数若为负，需商0，+y的绝对值补码得到正确余数
-------------------
运算器内部运行：（ACC累加器、MQ乘商寄存器、X通用寄存器）
ACC(被除数、余数) →← MQ(商)
    ↑↓
   ALU
    ↑
 X(除数)

---------------------------------------------------------
2.补码的除法：（加减交替法，符号位参与运算，被除数、余数、除数都用双符号位表示）
① 需要：被除数补码、除数补码、除数补码的负数
② 被除数和除数同号，则被除数减去除数（+除数补码的负数）
  被除数和除数异号，则被除数加上除数（+除数补码）
③ 余数和除数同号，则商1，余数左移一位减去除数
  余数和除数异号，则商0，余数左移一位加上除数
④ 重复n次，并且最后一次商固定置为1，余数也不用管正负
```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:860px;"><img src="组成原理/img/原码除法.jpg" alt=""></div>
</div>

### 5. 强制类型转换
```java
① 无符号数与有符号数：不改变数据内容，改变解释方式（看看最高位作为符号位还是数值位）
② 长整数变短整数：高位截断，保留低位
③ 短整形变长整形：符号扩展
```

### 6. 数据的存储和排列
```java
1.大小端模式：
① 大端方式：存放顺序是从高位有效字节（MSB）开始，便于人类阅读
② 小端方式：存放顺序是从低位有效字节（LSB）开始，便于机器处理

2. 边界对齐：
① 计算机通常按字节编制，即每个字节对应一个地址
② 通常也支持按字、按半字、按字节寻址
③ 假设存储字长为32位，则1个字=32bit，半字=16bit。每次访存只能读/写1个字
------------------
边界对齐方式：用空间换时间
边界不对齐方式：需要访问两次
```

### 7. 浮点数的表示
```java
1.浮点数的作用和基本原理：
① 阶码：符号位和数值位（常用补码和移码表示）
  尾数：符号位和具体数值精度（常用有原码和补码表示）
② 相当于十进制中的科学计数法，而二进制中尾数给出一个小数，阶码指明了小数点要向前/向后移动几位
-----------------
举个例子：a=0,01  b=1.1001
阶码0,01对应真值+1
尾数1.1001对应真值-0.0111
a的真值=2^1 * (-0.0111) = -0.111
1B存储空间正好：00111001

举个例子：a=0,10  b=0.01001
阶码0,01对应真值+2
尾数1.1001对应真值-0.01001
a的真值=2^2 * (+0.01001) = +1.001
1B存储空间不够：01000100 1（需规格化）

2.浮点数规格化：（左规、右规）
将上面的第二个例子：01000100 1 进行规格化
① 首先尾数b=0.01001，尾数的最高位是无效位（不是1），要尾数的最高位通过左移或者右移来改为1
② 尾数左移1位（尾数低位补0），阶码要-1
③ 如果尾数右移（尾数高位补1），阶码相对要+，（通常右规也会处理双符号位的溢出）

3.规格化浮点数的特点：
① 用原码表示的尾数进行规格化：（原码表示的最高位数值一定是1）
正数为0.1XXX...X
负数为1.1XXX...X
② 用补码表示的尾数进行规格化：（补码表示的最高位数值一定与符号位相反）
正数为0.1XXX...X
负数为1.0XXX...X
```

### 8. 浮点数标准 IEEE754（读作triple）
```java
1.IEEE745由以下部分组成：（数符、阶码、尾数数值位）
ms数符+E阶码(移码表示)+M尾数数值位(原码表示，隐藏最高位1：1.M)
---------------------
举个例子：将十进制数-0.75 转换为 IEEE754 的单精度浮点数格式表示（十进制转IEEE754，二进制作为中转）
① 先转成二进制：0.11 = (-1.1)*2^-1 （M尾数原码隐藏最高位1，所以要左移）
② 数符=1（正还是负）
③ 尾数部分=.1000000....（隐含最高位1）
④ 阶码真值=-1（能看出阶码，可求移码）
⑤ 单精度浮点型偏移量=127D（这是IEEE754单精度浮点数标准）
⑥ 移码=阶码真值+偏移量=-1 + 1111111 = 01111110（凑足8位）
⑦ 1 01111110 10000000000000000000000（分别为数符、阶码、尾数数值位）

举个例子：IEEE754 的单精度浮点数 CO A0 00 00 H的值是多少（IEEE754转十进制，二进制作为中转。跟上面的逆过来）
① 转二进制：1100 0000 1010 0000 0000 0000 0000 0000
② 数符=1
③ 尾数部分=.0100....（隐含最高位1）-> 尾数真值=1.01
④ 移码=10000001，若看做无符号数=129D（能看出移码。可求阶码）
⑤ 单精度浮点型偏移量=127D
⑥ 阶码真值=移码-偏移量=1000 0001 - 0111 1111 = 0000 0010 = 2
⑦ 浮点数真值=-1.01 * 2^2 = -1.25 * 2^2 = -5.0
----------------------------------
补充：（阶码为全1、全0用作特殊用途）
当阶码E全为0，尾数M不全为0时，表示非规格化小数
当阶码E全为0，尾数M全为0时，表示真值±0

当阶码E全为1，尾数M全为0时，表示无穷大 
当阶码E全为1，尾数M不全为0时，表示非数值“NaN”
```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:860px;"><img src="组成原理/img/IEEE754标准.jpg" alt=""></div>
</div>

### 9. 浮点数的加减运算
```java
① 对阶：阶数小的向大的靠齐
② 尾数加减，阶数照写
③ 规格化，如果尾数加减出现最高位是非0，则需要左规或右规
④ 舍入：0舌1入、恒置1
⑤ 判溢出：尾数溢出并未导致整体溢出，阶码溢出才是真溢出



```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:860px;"><img src="组成原理/img/浮点数加减运算.jpg" alt=""></div>
</div>