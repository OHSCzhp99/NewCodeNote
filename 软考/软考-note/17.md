## 上午 - 数据结构
---
### 1. 时间空间复杂度
```c

```

### 2. 栈队
```c

```

### 3. 串
```c
包含空格的字符串不是空串，空串是什么都不包含
字符串也是线性结构

最好：O(m)
最坏：O(n*m) (n-m+1)*m
平均：O(n+m)

串的模式匹配，求next（前面固定式01，不看当前，根据前后缀，匹配相同数再+1）
```
### 4. 数组
```c
当二维数组i=j时，无论是按行还是按列偏移量都相同

对称矩阵：对角线对称，压缩是只存储上三角或者下三角和对角线
i≤j（上三角）：j(j+1)/2+i+1
i≥j（下三角）：i(i+1)/2+j+1

三对角矩阵：元素集中在主对角线两侧带状区域
K=2i+j+1（i和j是行列，从0开始）
K=2i+j-2（i和j是行列，从1开始）

稀疏矩阵：存储方式有三元、十字链
```

### 5. 树
```c
m度、n结点
树结点总数：所有结点的度+1
（求叶子结点，可求出所有非叶子结点的度+1，得出树的结点总数再-非叶子结点）

树度：结点的度的最大值

层数上往下1开始
性质1：m^i-1（3^2=9） 3个结点的树 第3层有结点9个
性质2：m^h-1/m-1   
---------------------
二叉树：
性质1：2^i-1  2个结点的树 第i层的结点数
性质2：2^h-1  高度为h最多有多少结点

完全二叉树（右边的非叶子结点没有右叶子）
满二叉树（每个非叶子结点都有2个叶子）
平衡二叉树：任意结点左右孩子高度不超过1

左孩子：2i
右孩子：2i+1
----------------------
排序二叉树：
依次比较，小的左边，大的右边
单支数查找效率最差
中序能得到顺序
----------------------
最优二叉树：（哈夫曼树）
n个权值构造最优二叉树：2n-1

哈夫曼编码（不等长编码）：先构造哈夫曼树，左标0右标1
```

### 6. 图
```c
无向完全图：n(n-1)/2 条边（对称）
有向完全图：n(n-1)  条边（不对称）
强连通图：任意两个结点都有来回路径

度数和：2e

邻接矩阵：稠密图（有完全图）
链接表：稀疏图（表节点指出度）
几个定点就是几阶矩阵

矩阵非零数：
无向2e  
有向e
------------------
图的遍历：
深度优先：顶点能一直访问就访问，递归思想（栈）
广度优先：顶点自己的出度先访问完（队列）

邻接矩阵O(n^2)  
邻接表O(n+e)
```

### 7. 拓扑排序
```c
Vi再Vj之前，则：
可能存在弧<vi,vj>，一定不存在<vj,vi>（就是说，可能存在i到j，不存在j到i）

拓扑排序：O(n+e)
依次把入度为0的结点去掉，不能有回路，因为回路就不会有入度为0
```

### 8. 查找 - 二分
```c
静态：顺序、折半、分块
动态：平衡、排序、B_树、哈希表

顺序平均查找长度：(n+1)/2
二分：顺序存储（log2n-1），链表不行
（二分：大大、小小、大小交替）
```

### 9. 查找 - 哈希表
```c
解决冲突：（尽量减少，但避免不了）
尽可能使关键字的所有组成部分都能起作用
p 的值一般为不大于 n 且最接近 n 的质数

线性探测：冲突往后放，满了前面接上
二次探测：n^2,-(n^2)... （1，-1，2，-2，3，-3）
```

### 10. 查找 - 小顶堆大顶堆
```c
小顶堆：ki ≤ K2i、K2i+1
大顶堆：ki ≥ K2i、K2i+1
保持有分支的结点大于或者小于左右孩子（都是从下面的分支结点开始）
```

### 11. 排序
```c
直接插入：拿一个数跟相对有序的值比较，插入到合适的地方
希尔：插入升级版，增长间隔
选择：每次遍历选出最小值
冒泡：相邻两两比较
快速：双指针（头基准右边开始，尾基准左边开始），(分治)
归并：折半分解到不能分解，再合并，(分治)
```
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:650px;"><img src="软考/img/排序.jpg" alt=""></div>
</div>
<div style="background-color: rgb(206, 225, 225);  padding:20px; background-repeat: repeat;">
<div style="width:300px;"><img src="软考/img/排序诗.jpg" alt=""></div>
</div>

### 12. 算法
```c
0/1背包：（动态(最优)）
部分背包：（贪心(最优)）
时间复杂度：O(nW)

回溯：深度优先
分支限界：广度优先

矩阵连乘：（消消乐、动态）
时间复杂度：O(n3)
空间复杂度：O(n2)
```



